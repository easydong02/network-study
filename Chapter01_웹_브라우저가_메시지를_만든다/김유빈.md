# STORY 01 HTTP 리퀘스트 메시지를 작성한다

- 사용자가 브라우저에 URL 을 입력한 것을 해독하여 HTTP 요청 메시지를 생성하는 과정을 설명한다.

사용자는 원하는 기능을 수행하기 위해 브라우저의 주소창에 URL 을 입력합니다. URL 의 가장 앞단에 있는 프로토콜로 어느 성격의 서버에게 요청을 보낼 지 선택할 수 있습니다.

예를 들어, 웹 서버에게 요청을 보내기 위해서는 http 프로토콜을, 파일 서버에게 접근하기 위해서는 ftp 를 사용합니다. 프로토콜의 종류에 따라 이후에 오는 URL 의 정보가 달라집니다. 즉, 브라우저는 여러 성격의 서버에게 클라이언트 역할을 하며 어느 서버에게 요청을 보낼 지에 따라 필요한 정보가 다르기 때문에 이를 프로토콜로 구분합니다.

프로토콜을 이용하여 원하는 성격의 서버에 요청을 보낼 수 있습니다.

- 웹 서버 : http, https
- 파일 서버 : ftp
- 본인 PC 내 파일 접근 : file
- 메일 서버 : mailto
- 뉴스 서버 : news

웹 서버 요청 시 URL 은 다음과 같은 구조로 이루어져 있습니다.

`프로토콜:` + `//` + `웹 서버 명` + `/` + `디렉토리명` + `/` + … + `파일명`

URL 작성 시 파일명이 생략되어 있을 경우 서버 내 기본으로 설정되어 있는 파일 명으로 인식하며, 디렉토리명까지 생략되어 있을 경우 루트 경로로 판단합니다.

브라우저는 URL 의 구조에 따라 문자열을 파싱하여 다음과 같은 HTTP 요청 메시지를 생성합니다. 이 HTTP 요청 메시지를 원하는 서버에 전송하면 이를 해석하여 적절한 처리가 이루어집니다. HTTP 요청 메시지에는 서버에 정확히 어느 기능을 요청할 것인지에 대한 정보가 작성되어 있습니다.

```xml
# Request message
[Method] [URI] [HTTP version]
[field name] : [value]
...

[message]
```

HTTP 요청 메시지의 메서드(Method) 는 서버에 어떤 동작을 처리하고 싶은지 나타냅니다. 서버의 정보를 읽어오거나(GET), 생성 또는 수정(POST) 등의 동작을 명시합니다.

서버에서의 동작을 처리하면 서버는 클라이언트에게 HTTP 응답 메시지를 반환합니다. 이를 통해 서버의 동작이 제대로 처리되었는지 알 수 있습니다.

```xml
# Response message
[HTTP version] [status code] [message]
[field name] : [value]
...

[message]
```

응답 메시지의 앞 부분에 있는 status code 를 이용하여 실행 결과가 정상적으로 처리되었는지, 에러가 발생했는지 알 수 있습니다.

결과가 정상적으로 처리되어 브라우저에서 HTTP 응답 메시지를 수신하여 브라우저에 렌더링할 때, 영상이나 이미지 HTML 태그가 포함되어 있을 경우 서버에게 별도의 HTTP 요청 메시지를 전송하여 파일을 응답받습니다. 즉, HTTP 요청의 경우 하나의 요청에 하나의 응답만 받을 수 있으며, 이는 브라우저에서 판단하여 서버에게 요청을 보내는 방식으로 이루어집니다.

# STORY 02 웹 서버의 IP 주소를 DNS 서버에 조회한다

- 본격적으로 서버에 HTTP 메시지를 보내기 전, URL 의 도메인 주소를 IP 주소로 변환하는 과정을 설명한다.

TCP/IP 는 서브넷이라는 작은 네트워크를 라우터로 연결하여 전체 네트워크가 구성되는 방식입니다. 서브넷이란, 전체 네트워크에서 일부 작은 네트워크를 의미합니다. 여러 개의 서브넷을 라우터로 연결하면 네트워크 전체가 구성됩니다.

IP 주소는 기기의 주소와 같은 역할을 하며, 32비트의 숫자로 이루어져 있습니다. IP 는 서브넷 영역과 서브넷 내의 호스트 영역으로 구분되어 있는데, 이 영역은 정해져 있지 않습니다. 서브넷 영역을 구분하기 위해 어느 영역까지가 서브넷 영역인지 나타내는 것을 ‘넷마스크’ 라고 합니다.

`10.11.12.13/24` → 24가 넷마스크

24는 넷마스크의 1의 개수입니다. 넷마스크를 나열하면 다음과 같은 형태를 띕니다.

`11111111.11111111.11111111.00000000`

즉, 위의 IP 주소에서 10.11.12 까지가 서브넷 영역이며 13이 호스트 영역임을 알 수 있습니다.

호스트 영역의 모든 비트가 1인 경우 서브넷의 모든 기기에게 패킷을 보내는 브로드 캐스트를 의미합니다.

`10.11.12.255`

브라우저는 URL 을 해독하여 정해진 규칙에 따라 HTTP 메시지를 생성하지만 이를 서버에게 전송하는 기능이 없어, HTTP 메시지를 네트워크에 송출하기 위해 OS 에게 송신을 의뢰합니다. 다만, OS 는 네트워크 통신 시 도메인 주소가 아닌 IP 주소를 필요로 합니다. 따라서, OS 에 송신을 의뢰하기 전 사용자가 입력한 도메인 주소를 IP 주소로 변환하는 과정이 필요하며 해당 정보를 얻기 위해 DNS 서버에 접근해야 합니다.

결국 DNS 서버도 웹 서버처럼 서버일 뿐이며 통신하기 위해서는 요청 과정을 거쳐야합니다. 어플리케이션(ex. 브라우저) 에서 지원하는 소켓 라이브러리를 이용하여 DNS 서버에게 요청을 보낼 수 있습니다. 소켓 라이브러리의 API 를 이용하여 IP 주소를 응답받으면 이를 이용하여 OS 에게 실제로 보내고자 했던 서버에게 요청을 보내도록 의뢰할 수 있습니다.

DNS 서버에게 IP 주소를 받아오는 과정은 다음과 같습니다.

- 네트워크 어플리케이션에서 Socket 라이브러리 실행
- Socket 라이브러리의 gethostbyname(C언어 기준) API 를 호출하여 OS 의 프로토콜 스택에게 의뢰합니다.
    - DNS 서버에게 별도의 요청을 보내야 하기 때문에 마찬가지로 OS 에게 네트워크 통신을 의뢰합니다.
    - DNS 서버에게 요청 시에도 IP 주소로 요청해야하며, 해당 PC 의 기본 IP 주소를 설정할 수 있습니다.
- OS 의 프로토콜 스택은 DNS 서버에게 메시지를 전송하여 IP 를 받아옵니다.

받아온 IP 를 이용하여 다시 OS 에게 네트워크 통신을 의뢰하면 원하는 서버에게 요청을 보낼 수 있습니다.

# STORY 03 전 세계의 DNS 서버가 연대한다

## 1. DNS 서버의 기본 동작

- 클라이언트가 DNS 서버에게 요청을 보낼 때에는 **이름, 클래스, 타입**의 정보를 포함하여 요청을 보낸다.
  - 이름 : 도메인 주소
  - 타입 : 이름에 매칭되는 정보의 종류
    - A(Address) : IP 주소
    - MX(Mail eXchange) : 메일 주소(도메인 주소)

| 이름                  | 클래스 | 타입  | 클라이언트에 회답하는 항목      |
|---------------------|-----|-----|---------------------|
| www.lab.cyber.co.kr | IN  | A   | 192.0.2.226         |
| cyber.co.kr         | IN  | MX  | 10 mail.cyber.co.kr |
| mail.cyber.co.kr    | IN  | A   | 192.0.2.227         |
- DNS 서버는 내부적으로 위와 같이 데이터를 관리한다. (리소스 레코드)
- 클라이언트 요청 시 이름, 클래스, 타입이 모두 일치하는 항목을 찾아 응답한다.
  - [www.lab.cyber.co.kr](http://www.lab.cyber.co.kr) / IN / A → 192.0.2.226
  - [cyber.co.kr](http://cyber.co.kr) / IN / MX → 10 / [mail.cyber.co.kr](http://mail.cyber.co.kr) / 192.0.2.227

## 2. 도메인의 계층

- DNS 서버에서 도메인 주소와 IP 정보를 관리하지만, 전 세계에는 수많은 기기가 있다.
- 따라서 하나의 DNS 서버에서 모두를 관리하기에는 어려워, 다수의 DNS 가 연대하여 관리한다.
- 여러 대의 DNS 서버에서 도메인 주소를 쉽게 관리하기 위해 **도메인 주소를 계층화하여 관리**한다.
  - [www.lab.cyber.co.kr](http://www.lab.cyber.co.kr) 의 경우 kr(최상위 도메인) → co → cyber → lab → www 의 순서로 구성된다.

## 3. 담당 DNS 서버를 찾아 IP 주소를 가져온다

- 상위 DNS 서버에서 바로 아래 계층의 DNS 서버들을 저장하여 유기적으로 연결되도록 구성했다.
  - kr - [a.kr](http://a.kr) / [b.kr](http://b.kr) / [c.kr](http://c.kr) / … / co.kr
  - co - [a.co.kr](http://a.co.kr) / [b.co.kr](http://b.co.kr) / [c.co.kr](http://c.co.kr) / … / cyber.co.kr
  - cyber - [a.cyber.co.kr](http://a.cyber.co.kr) / [b.cyber.co.kr](http://b.cyber.co.kr/) / [c.cyber.co.kr](http://c.cyber.co.kr) / … / lab.cyber.co.kr
- 최상위 도메인(kr, com 등) 위에는 루트 도메인이 존재하여 최상위 도메인들을 관리한다.
  - 즉, 루트 도메인에서 시작한다면 최종적으로 원하는 도메인 서버에 접근할 수 있다.
    - [www.lab.cyber.co.kr](http://www.lab.cyber.co.kr) → 루트에서 kr 응답 → kr 에서 co 응답 → co 에서 cyber 응답 → …
- 이를 위해 모든 도메인 서버에서는 루트 도메인의 주소를 관리한다.
- 클라이언트는 가장 가까운 DNS 서버(TCP/IP 기본 설정값) 에게 요청하면 루트 도메인을 통해 원하는 DNS 서버의 위치를 찾을 수 있다.
  - 루트 도메인 : kr 도메인 서버의 IP 주소 응답
  - kr 도메인 : co 도메인 서버의 IP 주소 응답
  - co 도메인 : cyber 도메인 서버의 IP 주소 응답
  - 최종적으로 적절한 DNS 서버에게 요청하면 처음에 원했던 도메인 주소의 IP 주소를 응답받을 수 있다.

## 4. DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다

- 실제 DNS 서버에서는 한 대의 DNS 서버에 복수의 도메인 정보를 등록할 수 있다.
  - 하나의 DNS 서버에서 여러 계층의 정보를 바로 얻을 수 있다.
- DNS 서버에서 이전의 응답을 캐싱하여 보다 빠르게 응답받을 수 있다.
  - 캐시의 경우 오차가 발생할 수 있기 때문에 데이터 유효기간이 설정되어 있다.
  - 응답할 때 캐싱된 데이터인지 아닌지도 알려준다.

# STORY 04 프로토콜 스택에 메시지 송신을 의뢰한다

## 1. 데이터 송수신 동작의 개요

- DNS 서버로부터 IP 주소를 받으면 브라우저는 OS 에게 네트워크 통신을 의뢰하여 웹 서버에게 요청을 보낸다.
  - OS 에 의뢰할 때는 Socket 라이브러리를 사용한다.
- 서버에서 소켓을 생성하면 클라이언트에서 소켓 요청을 보내, 소켓 사이의 파이프를 연결하여 데이터를 송수신한다.
  1. 소켓 생성 (소켓 작성 단계)
  2. 서버 측의 소켓에 파이프를 연결합니다 (접속 단계)
  3. 데이터를 송수신합니다 (송수신 단계)
  4. 파이프를 분리하고 소켓을 말소합니다 (연결 끊기 단계)
- 서버나 클라이언트 어느 한 쪽에서 소켓을 종료하면 송수신이 종료된다.

## 2. 소켓의 작성 단계

- 클라이언트의 소켓을 생성하는 단계이다.
- Socket 라이브러리의 socket API 를 호출하여 생성한다.
  - 소켓을 생성하면 소켓 식별자인 디스크립터를 반환한다.

## 3. 파이프를 연결하는 접속 단계

- 클라이언트와 소켓과 서버의 소켓을 연결하는 단계이다.
- Socket 라이브러리의 connect API 를 호출하여 연결한다.
  - connect 를 호출할 때 디스크립터, 서버의 IP 주소, 포트 번호를 작성해야 한다.
  - IP 주소로 서버의 위치를 찾고, 포트 번호로 서버의 어플리케이션을 찾는다.

## 4. 메시지를 주고 받는 송수신 단계

- 클라이언트와 서버간 데이터를 주고받는 단계이다.
- Socket 라이브러리의 write API 를 호출하여 데이터를 송신한다.
  - write 를 호출할 때 디스크립터와 송신 데이터(요청 HTTP 메시지) 를 작성한다.
  - 파이프 연결 시 디스크립터에 해당하는 포트 번호가 저장되어 있기 때문에 디스크립터만으로 원하는 소켓을 지정할 수 있다.
- Socket 라이브러리의 read API 를 호출하여 데이터를 수신한다.
  - 응답받은 데이터는 메모리 영역(수신 버퍼) 에 저장 후 어플리케이션에게 전달된다.

## 5. 연결 끊기 단계에서 송수신이 종료된다

- 연결된 파이프를 종료하는 단계이다.
- Socket 라이브러리의 close API 를 호출하여 연결을 종료한다.
  - 보통 서버에서 데이터를 모두 송신하면 close 를 호출한다.
  - 클라이언트는 read 시 연결 종료 여부도 수신하여 이를 알 수 있다.
- HTTP 통신 시 하나의 웹 페이지에 영상 등의 데이터가 많이 포함되는 경우 한 번의 연결로 여러 데이터를 수신할 수도 있다.
